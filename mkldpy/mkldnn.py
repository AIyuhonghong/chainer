# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_mkldnn', [dirname(__file__)])
        except ImportError:
            import _mkldnn
            return _mkldnn
        if fp is not None:
            try:
                _mod = imp.load_module('_mkldnn', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _mkldnn = swig_import_helper()
    del swig_import_helper
else:
    import _mkldnn
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


PAGE_SIZE = _mkldnn.PAGE_SIZE

def global_init():
  return _mkldnn.global_init()
global_init = _mkldnn.global_init

def enabled():
  return _mkldnn.enabled()
enabled = _mkldnn.enabled

def set_mkldnn_enable(*args):
  return _mkldnn.set_mkldnn_enable(*args)
set_mkldnn_enable = _mkldnn.set_mkldnn_enable

def enable_google_logging():
  return _mkldnn.enable_google_logging()
enable_google_logging = _mkldnn.enable_google_logging
class Layer_F32(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer_F32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Layer_F32, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _mkldnn.delete_Layer_F32
    __del__ = lambda self : None;
    def forward(self): return _mkldnn.Layer_F32_forward(self)
    def backward(self): return _mkldnn.Layer_F32_backward(self)
    def setup_forward(self): return _mkldnn.Layer_F32_setup_forward(self)
    def setup_backward(self): return _mkldnn.Layer_F32_setup_backward(self)
    def __init__(self): 
        this = _mkldnn.new_Layer_F32()
        try: self.this.append(this)
        except: self.this = this
Layer_F32_swigregister = _mkldnn.Layer_F32_swigregister
Layer_F32_swigregister(Layer_F32)
cvar = _mkldnn.cvar

class Convolution2D_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Convolution2D_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Convolution2D_F32, name)
    __repr__ = _swig_repr
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.Convolution2D_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.Convolution2D_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.Convolution2D_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.Convolution2D_F32_do_backward)
    def __init__(self): 
        this = _mkldnn.new_Convolution2D_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_Convolution2D_F32
    __del__ = lambda self : None;
    def forward_setup(self, *args): return _mkldnn.Convolution2D_F32_forward_setup(self, *args)
    def forward(self, *args): return _mkldnn.Convolution2D_F32_forward(self, *args)
    def backward_setup(self, *args): return _mkldnn.Convolution2D_F32_backward_setup(self, *args)
    def backward(self, *args): return _mkldnn.Convolution2D_F32_backward(self, *args)
Convolution2D_F32_swigregister = _mkldnn.Convolution2D_F32_swigregister
Convolution2D_F32_swigregister(Convolution2D_F32)

def Convolution2D_F32_do_forward(*args):
  return _mkldnn.Convolution2D_F32_do_forward(*args)
Convolution2D_F32_do_forward = _mkldnn.Convolution2D_F32_do_forward

def Convolution2D_F32_do_backward(*args):
  return _mkldnn.Convolution2D_F32_do_backward(*args)
Convolution2D_F32_do_backward = _mkldnn.Convolution2D_F32_do_backward

class Pooling_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pooling_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pooling_F32, name)
    __repr__ = _swig_repr
    def forward(self, *args): return _mkldnn.Pooling_F32_forward(self, *args)
    def backward(self, *args): return _mkldnn.Pooling_F32_backward(self, *args)
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.Pooling_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.Pooling_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.Pooling_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.Pooling_F32_do_backward)
    def __init__(self): 
        this = _mkldnn.new_Pooling_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_Pooling_F32
    __del__ = lambda self : None;
Pooling_F32_swigregister = _mkldnn.Pooling_F32_swigregister
Pooling_F32_swigregister(Pooling_F32)

def Pooling_F32_do_forward(*args):
  return _mkldnn.Pooling_F32_do_forward(*args)
Pooling_F32_do_forward = _mkldnn.Pooling_F32_do_forward

def Pooling_F32_do_backward(*args):
  return _mkldnn.Pooling_F32_do_backward(*args)
Pooling_F32_do_backward = _mkldnn.Pooling_F32_do_backward

class MaxPooling_F32(Pooling_F32):
    __swig_setmethods__ = {}
    for _s in [Pooling_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaxPooling_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Pooling_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaxPooling_F32, name)
    __repr__ = _swig_repr
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.MaxPooling_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.MaxPooling_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.MaxPooling_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.MaxPooling_F32_do_backward)
    def __init__(self): 
        this = _mkldnn.new_MaxPooling_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_MaxPooling_F32
    __del__ = lambda self : None;
MaxPooling_F32_swigregister = _mkldnn.MaxPooling_F32_swigregister
MaxPooling_F32_swigregister(MaxPooling_F32)

def MaxPooling_F32_do_forward(*args):
  return _mkldnn.MaxPooling_F32_do_forward(*args)
MaxPooling_F32_do_forward = _mkldnn.MaxPooling_F32_do_forward

def MaxPooling_F32_do_backward(*args):
  return _mkldnn.MaxPooling_F32_do_backward(*args)
MaxPooling_F32_do_backward = _mkldnn.MaxPooling_F32_do_backward

class Relu4D_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Relu4D_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Relu4D_F32, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _mkldnn.new_Relu4D_F32()
        try: self.this.append(this)
        except: self.this = this
    def forward_setup(self, *args): return _mkldnn.Relu4D_F32_forward_setup(self, *args)
    def fwd_reset_mem(self, *args): return _mkldnn.Relu4D_F32_fwd_reset_mem(self, *args)
    def forward(self, *args): return _mkldnn.Relu4D_F32_forward(self, *args)
    def backward_setup(self, *args): return _mkldnn.Relu4D_F32_backward_setup(self, *args)
    def bwd_reset_mem(self, *args): return _mkldnn.Relu4D_F32_bwd_reset_mem(self, *args)
    def backward(self, *args): return _mkldnn.Relu4D_F32_backward(self, *args)
    __swig_getmethods__["get_forward_object"] = lambda x: _mkldnn.Relu4D_F32_get_forward_object
    if _newclass:get_forward_object = staticmethod(_mkldnn.Relu4D_F32_get_forward_object)
    __swig_getmethods__["get_backward_object"] = lambda x: _mkldnn.Relu4D_F32_get_backward_object
    if _newclass:get_backward_object = staticmethod(_mkldnn.Relu4D_F32_get_backward_object)
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.Relu4D_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.Relu4D_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.Relu4D_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.Relu4D_F32_do_backward)
    __swig_destroy__ = _mkldnn.delete_Relu4D_F32
    __del__ = lambda self : None;
Relu4D_F32_swigregister = _mkldnn.Relu4D_F32_swigregister
Relu4D_F32_swigregister(Relu4D_F32)

def Relu4D_F32_get_forward_object(*args):
  return _mkldnn.Relu4D_F32_get_forward_object(*args)
Relu4D_F32_get_forward_object = _mkldnn.Relu4D_F32_get_forward_object

def Relu4D_F32_get_backward_object(*args):
  return _mkldnn.Relu4D_F32_get_backward_object(*args)
Relu4D_F32_get_backward_object = _mkldnn.Relu4D_F32_get_backward_object

def Relu4D_F32_do_forward(*args):
  return _mkldnn.Relu4D_F32_do_forward(*args)
Relu4D_F32_do_forward = _mkldnn.Relu4D_F32_do_forward

def Relu4D_F32_do_backward(*args):
  return _mkldnn.Relu4D_F32_do_backward(*args)
Relu4D_F32_do_backward = _mkldnn.Relu4D_F32_do_backward

class Relu_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Relu_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Relu_F32, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _mkldnn.new_Relu_F32()
        try: self.this.append(this)
        except: self.this = this
    def forward_setup(self, *args): return _mkldnn.Relu_F32_forward_setup(self, *args)
    def fwd_reset_mem(self, *args): return _mkldnn.Relu_F32_fwd_reset_mem(self, *args)
    def forward(self, *args): return _mkldnn.Relu_F32_forward(self, *args)
    def backward_setup(self, *args): return _mkldnn.Relu_F32_backward_setup(self, *args)
    def bwd_reset_mem(self, *args): return _mkldnn.Relu_F32_bwd_reset_mem(self, *args)
    def backward(self, *args): return _mkldnn.Relu_F32_backward(self, *args)
    __swig_getmethods__["get_forward_object"] = lambda x: _mkldnn.Relu_F32_get_forward_object
    if _newclass:get_forward_object = staticmethod(_mkldnn.Relu_F32_get_forward_object)
    __swig_getmethods__["get_backward_object"] = lambda x: _mkldnn.Relu_F32_get_backward_object
    if _newclass:get_backward_object = staticmethod(_mkldnn.Relu_F32_get_backward_object)
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.Relu_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.Relu_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.Relu_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.Relu_F32_do_backward)
    __swig_destroy__ = _mkldnn.delete_Relu_F32
    __del__ = lambda self : None;
Relu_F32_swigregister = _mkldnn.Relu_F32_swigregister
Relu_F32_swigregister(Relu_F32)

def Relu_F32_get_forward_object(*args):
  return _mkldnn.Relu_F32_get_forward_object(*args)
Relu_F32_get_forward_object = _mkldnn.Relu_F32_get_forward_object

def Relu_F32_get_backward_object(*args):
  return _mkldnn.Relu_F32_get_backward_object(*args)
Relu_F32_get_backward_object = _mkldnn.Relu_F32_get_backward_object

def Relu_F32_do_forward(*args):
  return _mkldnn.Relu_F32_do_forward(*args)
Relu_F32_do_forward = _mkldnn.Relu_F32_do_forward

def Relu_F32_do_backward(*args):
  return _mkldnn.Relu_F32_do_backward(*args)
Relu_F32_do_backward = _mkldnn.Relu_F32_do_backward

class AvgPooling_F32(Pooling_F32):
    __swig_setmethods__ = {}
    for _s in [Pooling_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvgPooling_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Pooling_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvgPooling_F32, name)
    __repr__ = _swig_repr
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.AvgPooling_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.AvgPooling_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.AvgPooling_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.AvgPooling_F32_do_backward)
    def __init__(self): 
        this = _mkldnn.new_AvgPooling_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_AvgPooling_F32
    __del__ = lambda self : None;
AvgPooling_F32_swigregister = _mkldnn.AvgPooling_F32_swigregister
AvgPooling_F32_swigregister(AvgPooling_F32)

def AvgPooling_F32_do_forward(*args):
  return _mkldnn.AvgPooling_F32_do_forward(*args)
AvgPooling_F32_do_forward = _mkldnn.AvgPooling_F32_do_forward

def AvgPooling_F32_do_backward(*args):
  return _mkldnn.AvgPooling_F32_do_backward(*args)
AvgPooling_F32_do_backward = _mkldnn.AvgPooling_F32_do_backward

class Softmax_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Softmax_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Softmax_F32, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mkldnn.new_Softmax_F32(*args)
        try: self.this.append(this)
        except: self.this = this
    def update_user_mem(self, *args): return _mkldnn.Softmax_F32_update_user_mem(self, *args)
    def update_user_data(self, *args): return _mkldnn.Softmax_F32_update_user_data(self, *args)
    def is_first_fwd(self): return _mkldnn.Softmax_F32_is_first_fwd(self)
    def mark_first_fwd(self): return _mkldnn.Softmax_F32_mark_first_fwd(self)
    __swig_getmethods__["softmax_create_forward"] = lambda x: _mkldnn.Softmax_F32_softmax_create_forward
    if _newclass:softmax_create_forward = staticmethod(_mkldnn.Softmax_F32_softmax_create_forward)
    def get_res_size(self): return _mkldnn.Softmax_F32_get_res_size(self)
    def forward(self): return _mkldnn.Softmax_F32_forward(self)
    def backward(self): return _mkldnn.Softmax_F32_backward(self)
    def setup_forward(self): return _mkldnn.Softmax_F32_setup_forward(self)
    def setup_backward(self): return _mkldnn.Softmax_F32_setup_backward(self)
    __swig_destroy__ = _mkldnn.delete_Softmax_F32
    __del__ = lambda self : None;
Softmax_F32_swigregister = _mkldnn.Softmax_F32_swigregister
Softmax_F32_swigregister(Softmax_F32)

def Softmax_F32_softmax_create_forward(*args):
  return _mkldnn.Softmax_F32_softmax_create_forward(*args)
Softmax_F32_softmax_create_forward = _mkldnn.Softmax_F32_softmax_create_forward

class LocalResponseNormalization_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalResponseNormalization_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalResponseNormalization_F32, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mkldnn.new_LocalResponseNormalization_F32(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_LocalResponseNormalization_F32
    __del__ = lambda self : None;
    def forward(self): return _mkldnn.LocalResponseNormalization_F32_forward(self)
    __swig_getmethods__["get_workspace_size"] = lambda x: _mkldnn.LocalResponseNormalization_F32_get_workspace_size
    if _newclass:get_workspace_size = staticmethod(_mkldnn.LocalResponseNormalization_F32_get_workspace_size)
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.LocalResponseNormalization_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.LocalResponseNormalization_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.LocalResponseNormalization_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.LocalResponseNormalization_F32_do_backward)
LocalResponseNormalization_F32_swigregister = _mkldnn.LocalResponseNormalization_F32_swigregister
LocalResponseNormalization_F32_swigregister(LocalResponseNormalization_F32)

def LocalResponseNormalization_F32_get_workspace_size(*args):
  return _mkldnn.LocalResponseNormalization_F32_get_workspace_size(*args)
LocalResponseNormalization_F32_get_workspace_size = _mkldnn.LocalResponseNormalization_F32_get_workspace_size

def LocalResponseNormalization_F32_do_forward(*args):
  return _mkldnn.LocalResponseNormalization_F32_do_forward(*args)
LocalResponseNormalization_F32_do_forward = _mkldnn.LocalResponseNormalization_F32_do_forward

def LocalResponseNormalization_F32_do_backward(*args):
  return _mkldnn.LocalResponseNormalization_F32_do_backward(*args)
LocalResponseNormalization_F32_do_backward = _mkldnn.LocalResponseNormalization_F32_do_backward

class BatchNormalization_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BatchNormalization_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BatchNormalization_F32, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mkldnn.new_BatchNormalization_F32(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_BatchNormalization_F32
    __del__ = lambda self : None;
    def forward(self): return _mkldnn.BatchNormalization_F32_forward(self)
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.BatchNormalization_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.BatchNormalization_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.BatchNormalization_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.BatchNormalization_F32_do_backward)
BatchNormalization_F32_swigregister = _mkldnn.BatchNormalization_F32_swigregister
BatchNormalization_F32_swigregister(BatchNormalization_F32)

def BatchNormalization_F32_do_forward(*args):
  return _mkldnn.BatchNormalization_F32_do_forward(*args)
BatchNormalization_F32_do_forward = _mkldnn.BatchNormalization_F32_do_forward

def BatchNormalization_F32_do_backward(*args):
  return _mkldnn.BatchNormalization_F32_do_backward(*args)
BatchNormalization_F32_do_backward = _mkldnn.BatchNormalization_F32_do_backward

class Linear_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Linear_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Linear_F32, name)
    __repr__ = _swig_repr
    __swig_getmethods__["do_forward"] = lambda x: _mkldnn.Linear_F32_do_forward
    if _newclass:do_forward = staticmethod(_mkldnn.Linear_F32_do_forward)
    __swig_getmethods__["do_backward"] = lambda x: _mkldnn.Linear_F32_do_backward
    if _newclass:do_backward = staticmethod(_mkldnn.Linear_F32_do_backward)
    def __init__(self): 
        this = _mkldnn.new_Linear_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_Linear_F32
    __del__ = lambda self : None;
    def setup_forward(self, *args): return _mkldnn.Linear_F32_setup_forward(self, *args)
    def forward(self, *args): return _mkldnn.Linear_F32_forward(self, *args)
    def setup_backward(self, *args): return _mkldnn.Linear_F32_setup_backward(self, *args)
    def backward(self, *args): return _mkldnn.Linear_F32_backward(self, *args)
Linear_F32_swigregister = _mkldnn.Linear_F32_swigregister
Linear_F32_swigregister(Linear_F32)

def Linear_F32_do_forward(*args):
  return _mkldnn.Linear_F32_do_forward(*args)
Linear_F32_do_forward = _mkldnn.Linear_F32_do_forward

def Linear_F32_do_backward(*args):
  return _mkldnn.Linear_F32_do_backward(*args)
Linear_F32_do_backward = _mkldnn.Linear_F32_do_backward

class SoftmaxCrossEntropy_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftmaxCrossEntropy_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SoftmaxCrossEntropy_F32, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _mkldnn.new_SoftmaxCrossEntropy_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["softmax_cross_entropy_create_forward"] = lambda x: _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward
    if _newclass:softmax_cross_entropy_create_forward = staticmethod(_mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward)
    __swig_getmethods__["softmax_cross_entropy_create_backward"] = lambda x: _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward
    if _newclass:softmax_cross_entropy_create_backward = staticmethod(_mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward)
    def forward(self, *args): return _mkldnn.SoftmaxCrossEntropy_F32_forward(self, *args)
    def backward(self, *args): return _mkldnn.SoftmaxCrossEntropy_F32_backward(self, *args)
    __swig_destroy__ = _mkldnn.delete_SoftmaxCrossEntropy_F32
    __del__ = lambda self : None;
SoftmaxCrossEntropy_F32_swigregister = _mkldnn.SoftmaxCrossEntropy_F32_swigregister
SoftmaxCrossEntropy_F32_swigregister(SoftmaxCrossEntropy_F32)

def SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward(*args):
  return _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward(*args)
SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward = _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward

def SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward(*args):
  return _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward(*args)
SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward = _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward

class Concat_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Concat_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Concat_F32, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _mkldnn.new_Concat_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_Concat_F32
    __del__ = lambda self : None;
    def forward_setup(self, *args): return _mkldnn.Concat_F32_forward_setup(self, *args)
    def forward(self, *args): return _mkldnn.Concat_F32_forward(self, *args)
    def backward_setup(self, *args): return _mkldnn.Concat_F32_backward_setup(self, *args)
    def backward(self, *args): return _mkldnn.Concat_F32_backward(self, *args)
Concat_F32_swigregister = _mkldnn.Concat_F32_swigregister
Concat_F32_swigregister(Concat_F32)

class Sum_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sum_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sum_F32, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _mkldnn.new_Sum_F32()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mkldnn.delete_Sum_F32
    __del__ = lambda self : None;
    def sum_setup(self, *args): return _mkldnn.Sum_F32_sum_setup(self, *args)
    def sum(self, *args): return _mkldnn.Sum_F32_sum(self, *args)
Sum_F32_swigregister = _mkldnn.Sum_F32_swigregister
Sum_F32_swigregister(Sum_F32)

# This file is compatible with both classic and new-style classes.


