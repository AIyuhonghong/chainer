# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_mkldnn')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_mkldnn')
    _mkldnn = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_mkldnn', [dirname(__file__)])
        except ImportError:
            import _mkldnn
            return _mkldnn
        try:
            _mod = imp.load_module('_mkldnn', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _mkldnn = swig_import_helper()
    del swig_import_helper
else:
    import _mkldnn
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

PAGE_SIZE = _mkldnn.PAGE_SIZE

def global_init():
    return _mkldnn.global_init()
global_init = _mkldnn.global_init

def enabled():
    return _mkldnn.enabled()
enabled = _mkldnn.enabled

def set_mkldnn_enable(is_enabled):
    return _mkldnn.set_mkldnn_enable(is_enabled)
set_mkldnn_enable = _mkldnn.set_mkldnn_enable

def enable_google_logging():
    return _mkldnn.enable_google_logging()
enable_google_logging = _mkldnn.enable_google_logging
class Layer_F32(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer_F32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Layer_F32, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _mkldnn.delete_Layer_F32
    __del__ = lambda self: None

    def forward(self):
        return _mkldnn.Layer_F32_forward(self)

    def backward(self):
        return _mkldnn.Layer_F32_backward(self)

    def setup_forward(self):
        return _mkldnn.Layer_F32_setup_forward(self)

    def setup_backward(self):
        return _mkldnn.Layer_F32_setup_backward(self)

    def __init__(self):
        this = _mkldnn.new_Layer_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Layer_F32_swigregister = _mkldnn.Layer_F32_swigregister
Layer_F32_swigregister(Layer_F32)
cvar = _mkldnn.cvar

class Convolution2D_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Convolution2D_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Convolution2D_F32, name)
    __repr__ = _swig_repr
    if _newclass:
        do_forward = staticmethod(_mkldnn.Convolution2D_F32_do_forward)
    else:
        do_forward = _mkldnn.Convolution2D_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.Convolution2D_F32_do_backward)
    else:
        do_backward = _mkldnn.Convolution2D_F32_do_backward

    def __init__(self):
        this = _mkldnn.new_Convolution2D_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_Convolution2D_F32
    __del__ = lambda self: None

    def forward_setup(self, x, W, b, y, s1, s2, pl1, pl2, pr1, pr2):
        return _mkldnn.Convolution2D_F32_forward_setup(self, x, W, b, y, s1, s2, pl1, pl2, pr1, pr2)

    def forward(self, *args):
        return _mkldnn.Convolution2D_F32_forward(self, *args)

    def backward_setup(self, x, W, b, gy, gW, gx, gb):
        return _mkldnn.Convolution2D_F32_backward_setup(self, x, W, b, gy, gW, gx, gb)

    def backward(self, *args):
        return _mkldnn.Convolution2D_F32_backward(self, *args)
Convolution2D_F32_swigregister = _mkldnn.Convolution2D_F32_swigregister
Convolution2D_F32_swigregister(Convolution2D_F32)

def Convolution2D_F32_do_forward(*args):
    return _mkldnn.Convolution2D_F32_do_forward(*args)
Convolution2D_F32_do_forward = _mkldnn.Convolution2D_F32_do_forward

def Convolution2D_F32_do_backward(*args):
    return _mkldnn.Convolution2D_F32_do_backward(*args)
Convolution2D_F32_do_backward = _mkldnn.Convolution2D_F32_do_backward

class Pooling_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pooling_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pooling_F32, name)
    __repr__ = _swig_repr

    def forward(self, x, y, ws):
        return _mkldnn.Pooling_F32_forward(self, x, y, ws)

    def backward(self, gy, x, gx, ws):
        return _mkldnn.Pooling_F32_backward(self, gy, x, gx, ws)
    if _newclass:
        do_forward = staticmethod(_mkldnn.Pooling_F32_do_forward)
    else:
        do_forward = _mkldnn.Pooling_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.Pooling_F32_do_backward)
    else:
        do_backward = _mkldnn.Pooling_F32_do_backward

    def __init__(self):
        this = _mkldnn.new_Pooling_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_Pooling_F32
    __del__ = lambda self: None
Pooling_F32_swigregister = _mkldnn.Pooling_F32_swigregister
Pooling_F32_swigregister(Pooling_F32)

def Pooling_F32_do_forward(*args):
    return _mkldnn.Pooling_F32_do_forward(*args)
Pooling_F32_do_forward = _mkldnn.Pooling_F32_do_forward

def Pooling_F32_do_backward(*args):
    return _mkldnn.Pooling_F32_do_backward(*args)
Pooling_F32_do_backward = _mkldnn.Pooling_F32_do_backward

class MaxPooling_F32(Pooling_F32):
    __swig_setmethods__ = {}
    for _s in [Pooling_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaxPooling_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Pooling_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaxPooling_F32, name)
    __repr__ = _swig_repr
    if _newclass:
        do_forward = staticmethod(_mkldnn.MaxPooling_F32_do_forward)
    else:
        do_forward = _mkldnn.MaxPooling_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.MaxPooling_F32_do_backward)
    else:
        do_backward = _mkldnn.MaxPooling_F32_do_backward

    def __init__(self):
        this = _mkldnn.new_MaxPooling_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_MaxPooling_F32
    __del__ = lambda self: None
MaxPooling_F32_swigregister = _mkldnn.MaxPooling_F32_swigregister
MaxPooling_F32_swigregister(MaxPooling_F32)

def MaxPooling_F32_do_forward(x, y, ws, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w):
    return _mkldnn.MaxPooling_F32_do_forward(x, y, ws, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w)
MaxPooling_F32_do_forward = _mkldnn.MaxPooling_F32_do_forward

def MaxPooling_F32_do_backward(gy, x, gx, ws, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w):
    return _mkldnn.MaxPooling_F32_do_backward(gy, x, gx, ws, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w)
MaxPooling_F32_do_backward = _mkldnn.MaxPooling_F32_do_backward

class Relu4D_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Relu4D_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Relu4D_F32, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mkldnn.new_Relu4D_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def forward_setup(self, x, y):
        return _mkldnn.Relu4D_F32_forward_setup(self, x, y)

    def fwd_reset_mem(self, x, y):
        return _mkldnn.Relu4D_F32_fwd_reset_mem(self, x, y)

    def forward(self, x, y):
        return _mkldnn.Relu4D_F32_forward(self, x, y)

    def backward_setup(self, x, gy, gx):
        return _mkldnn.Relu4D_F32_backward_setup(self, x, gy, gx)

    def bwd_reset_mem(self, x, gy, gx):
        return _mkldnn.Relu4D_F32_bwd_reset_mem(self, x, gy, gx)

    def backward(self, x, gy, gx):
        return _mkldnn.Relu4D_F32_backward(self, x, gy, gx)
    if _newclass:
        get_forward_object = staticmethod(_mkldnn.Relu4D_F32_get_forward_object)
    else:
        get_forward_object = _mkldnn.Relu4D_F32_get_forward_object
    if _newclass:
        get_backward_object = staticmethod(_mkldnn.Relu4D_F32_get_backward_object)
    else:
        get_backward_object = _mkldnn.Relu4D_F32_get_backward_object
    if _newclass:
        do_forward = staticmethod(_mkldnn.Relu4D_F32_do_forward)
    else:
        do_forward = _mkldnn.Relu4D_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.Relu4D_F32_do_backward)
    else:
        do_backward = _mkldnn.Relu4D_F32_do_backward
    __swig_destroy__ = _mkldnn.delete_Relu4D_F32
    __del__ = lambda self: None
Relu4D_F32_swigregister = _mkldnn.Relu4D_F32_swigregister
Relu4D_F32_swigregister(Relu4D_F32)

def Relu4D_F32_get_forward_object(x_d1, x_d2, x_d3, x_d4):
    return _mkldnn.Relu4D_F32_get_forward_object(x_d1, x_d2, x_d3, x_d4)
Relu4D_F32_get_forward_object = _mkldnn.Relu4D_F32_get_forward_object

def Relu4D_F32_get_backward_object(x_d1, x_d2, x_d3, x_d4):
    return _mkldnn.Relu4D_F32_get_backward_object(x_d1, x_d2, x_d3, x_d4)
Relu4D_F32_get_backward_object = _mkldnn.Relu4D_F32_get_backward_object

def Relu4D_F32_do_forward(x, y):
    return _mkldnn.Relu4D_F32_do_forward(x, y)
Relu4D_F32_do_forward = _mkldnn.Relu4D_F32_do_forward

def Relu4D_F32_do_backward(x, gy, gx):
    return _mkldnn.Relu4D_F32_do_backward(x, gy, gx)
Relu4D_F32_do_backward = _mkldnn.Relu4D_F32_do_backward

class Relu_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Relu_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Relu_F32, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mkldnn.new_Relu_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def forward_setup(self, x, x_size, y, y_size):
        return _mkldnn.Relu_F32_forward_setup(self, x, x_size, y, y_size)

    def fwd_reset_mem(self, x, y):
        return _mkldnn.Relu_F32_fwd_reset_mem(self, x, y)

    def forward(self, x, x_size, y, y_size):
        return _mkldnn.Relu_F32_forward(self, x, x_size, y, y_size)

    def backward_setup(self, x, x_size, gy, gy_size, gx, gx_size):
        return _mkldnn.Relu_F32_backward_setup(self, x, x_size, gy, gy_size, gx, gx_size)

    def bwd_reset_mem(self, x, gy, gx):
        return _mkldnn.Relu_F32_bwd_reset_mem(self, x, gy, gx)

    def backward(self, x, x_size, gy, gy_size, gx, gx_size):
        return _mkldnn.Relu_F32_backward(self, x, x_size, gy, gy_size, gx, gx_size)
    if _newclass:
        get_forward_object = staticmethod(_mkldnn.Relu_F32_get_forward_object)
    else:
        get_forward_object = _mkldnn.Relu_F32_get_forward_object
    if _newclass:
        get_backward_object = staticmethod(_mkldnn.Relu_F32_get_backward_object)
    else:
        get_backward_object = _mkldnn.Relu_F32_get_backward_object
    if _newclass:
        do_forward = staticmethod(_mkldnn.Relu_F32_do_forward)
    else:
        do_forward = _mkldnn.Relu_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.Relu_F32_do_backward)
    else:
        do_backward = _mkldnn.Relu_F32_do_backward
    __swig_destroy__ = _mkldnn.delete_Relu_F32
    __del__ = lambda self: None
Relu_F32_swigregister = _mkldnn.Relu_F32_swigregister
Relu_F32_swigregister(Relu_F32)

def Relu_F32_get_forward_object(x_d1):
    return _mkldnn.Relu_F32_get_forward_object(x_d1)
Relu_F32_get_forward_object = _mkldnn.Relu_F32_get_forward_object

def Relu_F32_get_backward_object(x_d1):
    return _mkldnn.Relu_F32_get_backward_object(x_d1)
Relu_F32_get_backward_object = _mkldnn.Relu_F32_get_backward_object

def Relu_F32_do_forward(x, y):
    return _mkldnn.Relu_F32_do_forward(x, y)
Relu_F32_do_forward = _mkldnn.Relu_F32_do_forward

def Relu_F32_do_backward(x, gy, gx):
    return _mkldnn.Relu_F32_do_backward(x, gy, gx)
Relu_F32_do_backward = _mkldnn.Relu_F32_do_backward

class AvgPooling_F32(Pooling_F32):
    __swig_setmethods__ = {}
    for _s in [Pooling_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvgPooling_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Pooling_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvgPooling_F32, name)
    __repr__ = _swig_repr
    if _newclass:
        do_forward = staticmethod(_mkldnn.AvgPooling_F32_do_forward)
    else:
        do_forward = _mkldnn.AvgPooling_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.AvgPooling_F32_do_backward)
    else:
        do_backward = _mkldnn.AvgPooling_F32_do_backward

    def __init__(self):
        this = _mkldnn.new_AvgPooling_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_AvgPooling_F32
    __del__ = lambda self: None
AvgPooling_F32_swigregister = _mkldnn.AvgPooling_F32_swigregister
AvgPooling_F32_swigregister(AvgPooling_F32)

def AvgPooling_F32_do_forward(x, y, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w):
    return _mkldnn.AvgPooling_F32_do_forward(x, y, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w)
AvgPooling_F32_do_forward = _mkldnn.AvgPooling_F32_do_forward

def AvgPooling_F32_do_backward(gy, x, gx, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w):
    return _mkldnn.AvgPooling_F32_do_backward(gy, x, gx, s_y, s_x, p_u, p_d, p_l, p_r, ker_h, ker_w)
AvgPooling_F32_do_backward = _mkldnn.AvgPooling_F32_do_backward

class Softmax_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Softmax_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Softmax_F32, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mkldnn.new_Softmax_F32(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def update_user_mem(self, x, y):
        return _mkldnn.Softmax_F32_update_user_mem(self, x, y)

    def update_user_data(self, src_mem, dst_mem):
        return _mkldnn.Softmax_F32_update_user_data(self, src_mem, dst_mem)

    def is_first_fwd(self):
        return _mkldnn.Softmax_F32_is_first_fwd(self)

    def mark_first_fwd(self):
        return _mkldnn.Softmax_F32_mark_first_fwd(self)
    if _newclass:
        softmax_create_forward = staticmethod(_mkldnn.Softmax_F32_softmax_create_forward)
    else:
        softmax_create_forward = _mkldnn.Softmax_F32_softmax_create_forward

    def get_res_size(self):
        return _mkldnn.Softmax_F32_get_res_size(self)

    def forward(self):
        return _mkldnn.Softmax_F32_forward(self)

    def backward(self):
        return _mkldnn.Softmax_F32_backward(self)

    def setup_forward(self):
        return _mkldnn.Softmax_F32_setup_forward(self)

    def setup_backward(self):
        return _mkldnn.Softmax_F32_setup_backward(self)
    __swig_destroy__ = _mkldnn.delete_Softmax_F32
    __del__ = lambda self: None
Softmax_F32_swigregister = _mkldnn.Softmax_F32_swigregister
Softmax_F32_swigregister(Softmax_F32)

def Softmax_F32_softmax_create_forward(x, y, dims, axis):
    return _mkldnn.Softmax_F32_softmax_create_forward(x, y, dims, axis)
Softmax_F32_softmax_create_forward = _mkldnn.Softmax_F32_softmax_create_forward

class LocalResponseNormalization_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalResponseNormalization_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalResponseNormalization_F32, name)
    __repr__ = _swig_repr

    def __init__(self, n, k, alpha, beta, alg_kind):
        this = _mkldnn.new_LocalResponseNormalization_F32(n, k, alpha, beta, alg_kind)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_LocalResponseNormalization_F32
    __del__ = lambda self: None

    def forward(self):
        return _mkldnn.LocalResponseNormalization_F32_forward(self)
    if _newclass:
        get_workspace_size = staticmethod(_mkldnn.LocalResponseNormalization_F32_get_workspace_size)
    else:
        get_workspace_size = _mkldnn.LocalResponseNormalization_F32_get_workspace_size
    if _newclass:
        do_forward = staticmethod(_mkldnn.LocalResponseNormalization_F32_do_forward)
    else:
        do_forward = _mkldnn.LocalResponseNormalization_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.LocalResponseNormalization_F32_do_backward)
    else:
        do_backward = _mkldnn.LocalResponseNormalization_F32_do_backward
LocalResponseNormalization_F32_swigregister = _mkldnn.LocalResponseNormalization_F32_swigregister
LocalResponseNormalization_F32_swigregister(LocalResponseNormalization_F32)

def LocalResponseNormalization_F32_get_workspace_size(*args):
    return _mkldnn.LocalResponseNormalization_F32_get_workspace_size(*args)
LocalResponseNormalization_F32_get_workspace_size = _mkldnn.LocalResponseNormalization_F32_get_workspace_size

def LocalResponseNormalization_F32_do_forward(*args):
    return _mkldnn.LocalResponseNormalization_F32_do_forward(*args)
LocalResponseNormalization_F32_do_forward = _mkldnn.LocalResponseNormalization_F32_do_forward

def LocalResponseNormalization_F32_do_backward(*args):
    return _mkldnn.LocalResponseNormalization_F32_do_backward(*args)
LocalResponseNormalization_F32_do_backward = _mkldnn.LocalResponseNormalization_F32_do_backward

class BatchNormalization_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BatchNormalization_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BatchNormalization_F32, name)
    __repr__ = _swig_repr

    def __init__(self, eps, is_training, has_weights, fixed_mean_var):
        this = _mkldnn.new_BatchNormalization_F32(eps, is_training, has_weights, fixed_mean_var)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_BatchNormalization_F32
    __del__ = lambda self: None

    def forward(self):
        return _mkldnn.BatchNormalization_F32_forward(self)
    if _newclass:
        do_forward = staticmethod(_mkldnn.BatchNormalization_F32_do_forward)
    else:
        do_forward = _mkldnn.BatchNormalization_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.BatchNormalization_F32_do_backward)
    else:
        do_backward = _mkldnn.BatchNormalization_F32_do_backward
BatchNormalization_F32_swigregister = _mkldnn.BatchNormalization_F32_swigregister
BatchNormalization_F32_swigregister(BatchNormalization_F32)

def BatchNormalization_F32_do_forward(x, y, W, mean, var, eps, is_training, has_weights, fixed_mean_var):
    return _mkldnn.BatchNormalization_F32_do_forward(x, y, W, mean, var, eps, is_training, has_weights, fixed_mean_var)
BatchNormalization_F32_do_forward = _mkldnn.BatchNormalization_F32_do_forward

def BatchNormalization_F32_do_backward(x, W, mean, var, gy, gx, gW, eps, is_training, has_weights, fixed_mean_var):
    return _mkldnn.BatchNormalization_F32_do_backward(x, W, mean, var, gy, gx, gW, eps, is_training, has_weights, fixed_mean_var)
BatchNormalization_F32_do_backward = _mkldnn.BatchNormalization_F32_do_backward

class Linear_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Linear_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Linear_F32, name)
    __repr__ = _swig_repr
    if _newclass:
        do_forward = staticmethod(_mkldnn.Linear_F32_do_forward)
    else:
        do_forward = _mkldnn.Linear_F32_do_forward
    if _newclass:
        do_backward = staticmethod(_mkldnn.Linear_F32_do_backward)
    else:
        do_backward = _mkldnn.Linear_F32_do_backward

    def __init__(self):
        this = _mkldnn.new_Linear_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_Linear_F32
    __del__ = lambda self: None

    def setup_forward(self, x, W, b, y):
        return _mkldnn.Linear_F32_setup_forward(self, x, W, b, y)

    def forward(self, *args):
        return _mkldnn.Linear_F32_forward(self, *args)

    def setup_backward(self, x, W, b, gy, gW, gx, gb):
        return _mkldnn.Linear_F32_setup_backward(self, x, W, b, gy, gW, gx, gb)

    def backward(self, *args):
        return _mkldnn.Linear_F32_backward(self, *args)
Linear_F32_swigregister = _mkldnn.Linear_F32_swigregister
Linear_F32_swigregister(Linear_F32)

def Linear_F32_do_forward(*args):
    return _mkldnn.Linear_F32_do_forward(*args)
Linear_F32_do_forward = _mkldnn.Linear_F32_do_forward

def Linear_F32_do_backward(*args):
    return _mkldnn.Linear_F32_do_backward(*args)
Linear_F32_do_backward = _mkldnn.Linear_F32_do_backward

class SoftmaxCrossEntropy_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftmaxCrossEntropy_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SoftmaxCrossEntropy_F32, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mkldnn.new_SoftmaxCrossEntropy_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        softmax_cross_entropy_create_forward = staticmethod(_mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward)
    else:
        softmax_cross_entropy_create_forward = _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward
    if _newclass:
        softmax_cross_entropy_create_backward = staticmethod(_mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward)
    else:
        softmax_cross_entropy_create_backward = _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward

    def forward(self, x, y, dims):
        return _mkldnn.SoftmaxCrossEntropy_F32_forward(self, x, y, dims)

    def backward(self, gx, label, dims):
        return _mkldnn.SoftmaxCrossEntropy_F32_backward(self, gx, label, dims)
    __swig_destroy__ = _mkldnn.delete_SoftmaxCrossEntropy_F32
    __del__ = lambda self: None
SoftmaxCrossEntropy_F32_swigregister = _mkldnn.SoftmaxCrossEntropy_F32_swigregister
SoftmaxCrossEntropy_F32_swigregister(SoftmaxCrossEntropy_F32)

def SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward(dims):
    return _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward(dims)
SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward = _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_forward

def SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward(dims):
    return _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward(dims)
SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward = _mkldnn.SoftmaxCrossEntropy_F32_softmax_cross_entropy_create_backward

class Concat_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Concat_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Concat_F32, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mkldnn.new_Concat_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_Concat_F32
    __del__ = lambda self: None

    def forward_setup(self, num_concats, concat_input, y, axis):
        return _mkldnn.Concat_F32_forward_setup(self, num_concats, concat_input, y, axis)

    def forward(self, num_concats, y, axis):
        return _mkldnn.Concat_F32_forward(self, num_concats, y, axis)

    def backward_setup(self, num_concats, concat_output, gy, axis):
        return _mkldnn.Concat_F32_backward_setup(self, num_concats, concat_output, gy, axis)

    def backward(self, num_concats, gy, axis):
        return _mkldnn.Concat_F32_backward(self, num_concats, gy, axis)
Concat_F32_swigregister = _mkldnn.Concat_F32_swigregister
Concat_F32_swigregister(Concat_F32)

class Sum_F32(Layer_F32):
    __swig_setmethods__ = {}
    for _s in [Layer_F32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sum_F32, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer_F32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sum_F32, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mkldnn.new_Sum_F32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mkldnn.delete_Sum_F32
    __del__ = lambda self: None

    def sum_setup(self, num_sum, sum_input, y):
        return _mkldnn.Sum_F32_sum_setup(self, num_sum, sum_input, y)

    def sum(self, num_sum, y):
        return _mkldnn.Sum_F32_sum(self, num_sum, y)
Sum_F32_swigregister = _mkldnn.Sum_F32_swigregister
Sum_F32_swigregister(Sum_F32)

# This file is compatible with both classic and new-style classes.


